var language_score = DEFAULT_LANGUAGE_SCORE
do if (args.LANGUAGE_SCORE != null)
    eval language_score = args.LANGUAGE_SCORE

var command = function (language) {
    raw ${args.COMMAND_MODIFIER} expand {
        switch(args.COMMAND) {
            
            case "bossbar": {
                switch(args.CHOICE) {
                    case "add": {
                        bossbar add ${args.RESOURCE_LOCATION} ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                        break
                    }
                    case "set": {
                        bossbar set ${args.RESOURCE_LOCATION} name ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                        break
                    }
                }
                break
            }
            
            case "data": {
                switch(args.CHOICE) {
                    case "merge": {
                        switch(args.CHOICE_LITERAL) {
                            case "block": {
                                data merge block ${args.COORDINATE_SET} ${translateNBT(args.NBT_COMPOUND, language.values)}
                                break
                            }
                            case "entity": {
                                data merge entity ${args.ENTITY} ${translateNBT(args.NBT_COMPOUND, language.values)}
                                break
                            }
                            case "storage": {
                                data merge storage ${args.RESOURCE_LOCATION} ${translateNBT(args.NBT_COMPOUND, language.values)}
                                break
                            }
                        }
                        break
                    }
                    case "modify": {
                        switch(args.CHOICE_OPERATION) {
                            case "append": {
                                switch(args.CHOICE_LITERAL) {
                                    case "block": {
                                        data modify block ${args.COORDINATE_SET} ${args.NBT_PATH} append value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "entity": {
                                        data modify entity ${args.ENTITY} ${args.NBT_PATH} append value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "storage": {
                                        data modify storage ${args.RESOURCE_LOCATION} ${args.NBT_PATH} append value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                }
                                break
                            }
                            case "insert": {
                                switch(args.CHOICE_LITERAL) {
                                    case "block": {
                                        data modify block ${args.COORDINATE_SET} ${args.NBT_PATH} insert ${args.INDEX} value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "entity": {
                                        data modify entity ${args.ENTITY} ${args.NBT_PATH} insert ${args.INDEX} value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "storage": {
                                        data modify storage ${args.RESOURCE_LOCATION} ${args.NBT_PATH} insert ${args.INDEX} value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                }
                                break
                            }
                            case "merge": {
                                switch(args.CHOICE_LITERAL) {
                                    case "block": {
                                        data modify block ${args.COORDINATE_SET} ${args.NBT_PATH} merge value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "entity": {
                                        data modify entity ${args.ENTITY} ${args.NBT_PATH} merge value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "storage": {
                                        data modify storage ${args.RESOURCE_LOCATION} ${args.NBT_PATH} merge value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                }
                                break
                            }
                            case "prepend": {
                                switch(args.CHOICE_LITERAL) {
                                    case "block": {
                                        data modify block ${args.COORDINATE_SET} ${args.NBT_PATH} prepend value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "entity": {
                                        data modify entity ${args.ENTITY} ${args.NBT_PATH} prepend value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "storage": {
                                        data modify storage ${args.RESOURCE_LOCATION} ${args.NBT_PATH} prepend value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                }
                                break
                            }
                            case "set": {
                                switch(args.CHOICE_LITERAL) {
                                    case "block": {
                                        data modify block ${args.COORDINATE_SET} ${args.NBT_PATH} set value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "entity": {
                                        data modify entity ${args.ENTITY} ${args.NBT_PATH} set value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                    case "storage": {
                                        data modify storage ${args.RESOURCE_LOCATION} ${args.NBT_PATH} set value ${translateNBT(args.NBT_VALUE, language.values)}
                                        break
                                    }
                                }
                                break
                            }
                        }
                        break
                    }
                }
                break
            }
            
            case "fill": {
                switch(args.CHOICE) {
                    case null: {
                        fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)}
                    }
                    case "destroy": {
                        fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)} destroy
                        break
                    }
                    case "hollow": {
                        fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)} hollow
                        break
                    }
                    case "keep": {
                        fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)} keep
                        break
                    }
                    case "outline": {
                        fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)} outline
                        break
                    }
                    case "replace": {
                        do if (args.REPLACE == null)
                            fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)} replace
                        else
                            fill ${args.FROM} ${args.TO} ${translateBlock(args.BLOCK, language.values)} replace ${translateBlock(args.REPLACE, language.values)}
                        break
                    }
                }
                break
            }
            
            case "give": {
                do if (args.AMOUNT == null)
                    give ${args.ENTITY} ${translateItem(args.ITEM, language.values)}
                else
                    give ${args.ENTITY} ${translateItem(args.ITEM, language.values)} ${args.AMOUNT}
                break
            }
            
            case "replaceitem": {
                switch(args.CHOICE_LITERAL) {
                    case "block": {
                        do if (args.COUNT == null)
                            replaceitem block ${args.COORDINATE_SET} ${args.SLOT_ID} ${translateItem(args.ITEM, language.values)}
                        else
                            replaceitem block ${args.COORDINATE_SET} ${args.SLOT_ID} ${translateItem(args.ITEM, language.values)} ${args.COUNT}
                        break
                    }
                    case "entity": {
                        do if (args.COUNT == null)
                            replaceitem entity ${args.ENTITY} ${args.SLOT_ID} ${translateItem(args.ITEM, language.values)}
                        else
                            replaceitem entity ${args.ENTITY} ${args.SLOT_ID} ${translateItem(args.ITEM, language.values)} ${args.COUNT}
                        break
                    }
                }
                break
            }
            
            case "set": {
                set ${args.POINTER} = ${translateNBT(args.NBT_VALUE, language.values)}
                break
            }
            
            case "setblock": {
                do if (args.OLD_BLOCK_HANDLING == null)
                    setblock ${args.COORDINATE_SET} ${translateBlock(args.BLOCK, language.values)}
                else
                    switch(args.OLD_BLOCK_HANDLING) {
                        case "replace": {
                            setblock ${args.COORDINATE_SET} ${translateBlock(args.BLOCK, language.values)} replace
                            break
                        }
                        case "destroy": {
                            setblock ${args.COORDINATE_SET} ${translateBlock(args.BLOCK, language.values)} destroy
                            break
                        }
                        case "keep": {
                            setblock ${args.COORDINATE_SET} ${translateBlock(args.BLOCK, language.values)} keep
                            break
                        }
                    }
                break
            }
            
            case "summon": {
                do if (args.COORDINATE_SET == null)
                    summon ${translateNewEntity(args.NEW_ENTITY_LITERAL, language.values)}
                else do if (args.NBT_COMPOUND == null)
                    summon ${translateNewEntity(args.NEW_ENTITY_LITERAL, language.values)} ${args.COORDINATE_SET}
                else
                    summon ${translateNewEntity(args.NEW_ENTITY_LITERAL, language.values)} ${args.COORDINATE_SET} ${translateNBT(args.NBT_COMPOUND, language.values)}
                break
            }
            
            case "team": {
                switch(args.CHOICE) {
                    case "add": {
                        team add ${args.TEAM} ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                        break
                    }
                    case "modify": {
                        switch(args.OPTION) {
                            case "displayName": {
                                team modify ${args.TEAM} displayName ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                                break
                            }
                            case "prefix": {
                                team modify ${args.TEAM} prefix ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                                break
                            }
                            case "suffix": {
                                team modify ${args.TEAM} suffix ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                                break
                            }
                        }
                        break
                    }
                }
                break
            }
            
            case "tellraw": {
                tellraw ${args.ENTITY} ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                break
            }
            
            case "title": {
                switch(args.CHOICE) {
                    case "title": {
                        title ${args.ENTITY} title ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                        break
                    }
                    case "subtitle": {
                        title ${args.ENTITY} subtitle ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                        break
                    }
                    case "actionbar": {
                        title ${args.ENTITY} actionbar ${translateTextComponent(args.TEXT_COMPONENT, language.values)}
                        break
                    }
                }
                break
            }
            
            case "using": {
                do if (args.COORDINATE_SET == null)
                    function {
                        using summon ${translateNewEntity(args.NEW_ENTITY_LITERAL, language.values)}
                        with ${args.TAG_NAME} raw ${args.MODIFIER} {
                            do if (args.ANONYMOUS_INNER_FUNCTION != null)
                                eval args.ANONYMOUS_INNER_FUNCTION()
                        }
                    }
                else do if (args.NBT_COMPOUND == null)
                    function {
                        using summon ${translateNewEntity(args.NEW_ENTITY_LITERAL, language.values)} ${args.COORDINATE_SET}
                        with ${args.TAG_NAME} raw ${args.MODIFIER} {
                            do if (args.ANONYMOUS_INNER_FUNCTION != null)
                                eval args.ANONYMOUS_INNER_FUNCTION()
                        }
                    }
                else
                    function {
                        using summon ${translateNewEntity(args.NEW_ENTITY_LITERAL, language.values)} ${args.COORDINATE_SET} 
                        ${translateNBT(args.NBT_COMPOUND, language.values)} with ${args.TAG_NAME} raw ${args.MODIFIER} {
                            do if (args.ANONYMOUS_INNER_FUNCTION != null)
                                eval args.ANONYMOUS_INNER_FUNCTION()
                        }
                    }
                break
            }
        }
    }
}

var _generateTree = function (start, n, end) {
    if score deref $language_score matches $start..$n expand {
        eval generateTree(start, n, true)
    }
    if score deref $language_score matches ${n + 1}..$end expand {
        eval generateTree(n + 1, end, true)
    }
}

var generateTree = function (start, end, inner) {
    do if(start != end) {
        var n = start + (int) Math.pow(2, (int) Math.log2(end - start)) - 1
        do if (inner == true) 
            function { eval _generateTree(start, n, end) }
        else 
            eval _generateTree(start, n, end)
    }
    else eval command(languages[start])
}

var commands = function() {
    do if (languages.length > 3)
        eval generateTree(0, languages.length - 1)
    else
        for (language in languages) {
            if score deref $language_score matches ${language.index} expand {
                eval command(language)
            }
        }
}

do if (modifiers.length == 0)
    eval commands()
else
    raw $modifiers function {
        eval commands()
    }
